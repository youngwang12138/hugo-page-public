[{"content":"表结构及插入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  DROPTABLEIFEXISTS`listings`;CREATETABLE`listings`(`store_id`int(11)DEFAULTNULL,`id`int(11)NOTNULLAUTO_INCREMENT,`product_id`int(11)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=InnoDBDEFAULTCHARSET=utf8mb4COLLATE=utf8mb4_unicode_ci;LOCKTABLES`listings`WRITE;/*!40000 ALTER TABLE `listings` DISABLE KEYS */;INSERTINTO`listings`(`store_id`,`id`,`product_id`)VALUES(3,1,1),(3,2,2),(3,3,1),(3,4,1),(3,5,2);/*!40000 ALTER TABLE `listings` ENABLE KEYS */;UNLOCKTABLES;  查看表数据 1  selectproduct_id,store_id,idfromlistings;  查询store id 为3，product_id 分别为1和2里ID最大的行数据 1  selectproduct_id,store_id,max(id)idfromlistingswhereproduct_idin(1,2)andstore_id=3groupbyproduct_id;  ","date":"2022-09-04T23:41:10Z","permalink":"https://zhongyang.wang/post/1662306070/","title":"MySQL 分组后取每组ID最大的行"},{"content":"前言 每个表中的数据被分成页。构成每个表的页面排列在称为B+树索引的树数据结构中。表数据和二级索引都使用这种类型的结构。页又可以分为数据页和索引页，是MySQL数据存储的最小单元，默认为16kb。B+树中的一个叶子节点是一页\n结构图 其中上半部分为索引页，下半部分为数据页\n数据页 数据行 数据页是磁盘中的一段数据，那么里面记录的就是数据行。数据行是一个单向链表结构，由前一行指向下一行\n页目录 如果数据页里的行数少，那么可以直接遍历。当数据越来越多时，直接遍历就很慢了，那就需要给这些行创建目录\u0026mdash;页目录。 如果页目录如果给每行记录都加一个目录项，那就没有意义了。这里使用稀疏索引，每个目录项记录第一行数据的id。先在页目录中通过二分查找确定目录项，再遍历目录项指向的单向链表遍历数据。MySQL会自动的维护页目录 那么问题来了，如果数据一个数据页放不下，在数据遍历的时候怎么办呢？数据页双向链表的结构优化这个问题。(对应于聚簇索引里叶子节点的双向链表便于遍历)\n索引页 当数据页很多的时候，如何确定去哪页查找数据呢？这就是索引页的作用。 类似于页目录的方式，对每一个数据页提取最小id和页地址信息，通过二分查找的方式确定数据页地址。当数据页很多的时候，随着二叉树高度的增加，查找效率就下降了，有没有更好的方式呢？ 要加快树的查找效率，那就压缩树的高度。把原本每个非叶子节点只存一个数据的形式，改成可以存放16个，树的高度大大降低。 如果记录按顺序插入，索引页的填充因子为15/16，否则是1/2~15/16(随机插入时，会发生频繁的也分裂合并操作，性能很低；且也会数据会变得稀疏不规则，会存在数据碎片)。\n以上数据页加上索引页就形成了聚簇索引。\n一颗聚簇索引可以覆盖多少数据呢 主键索引非叶子节点存放主键值和指针，地址和主键大小按照文档分别为5字节和6字节；每条数据按照500字节算，每个数据页大概可以存放16*1024/500=32条数据。 当树高为1时，root节点为叶子节点，直接存数据16*1024/500=32 当树高为2时，可索引的数据页为16*1024/11=1490，数据量为1460*32=47680 当树高为3时，数据量为1460*1490*32=71043200，在达到这个数据量前，基本就需要考虑分表了。\n缓冲池全部为B+树时可以多少数据呢 缓冲池的默认大小为128M，可以通过参数innodb_buffer_pool_size配置,比如10G。假如128M全部加载B+树，数据量为128*1024/16*32=262144\n","date":"2022-08-09T21:15:10Z","permalink":"https://zhongyang.wang/post/1660050910/","title":"mysql数据页和索引页"},{"content":"前言 做权限验证时，需要对传入的路由与配置的路由进行匹配，判断是否对API有权限。这里比较通过字典树和正则匹配这两种实现方式的性能差异\n权限信息 里面主要包含roleId、url、method\n1 2 3 4 5 6 7 8 9 10 11  { \u0026#34;role_id\u0026#34;: 5, \u0026#34;role_name\u0026#34;: \u0026#34;超级管理员\u0026#34;, \u0026#34;apis\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;github.com/go-redis/:str/redis/v8\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34; } ] }   字典树的实现方式 1 2 3 4 5 6  // 获取一个对象 roleTrieTest = NewRoleTrie() // 根据权限信息生成树 roleTrieTest.Generate(*roleInfo) // 查找，符合条件返回true roleTrieTest.Search(roleId, url, urlMethod)   正则匹配的实现方式 1 2 3 4 5 6  // 获取一个对象 roleTrieTest = NewRoleTrie() // 根据权限信息生成role拥有的URL正则表达式列表 roleTrieTest.Generate(*roleInfo) // 查找，符合条件返回true roleTrieTest.Search(roleId, url, urlMethod)   Bench 测试代码如下 测试只针对查找过程，不包含生成查找信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  func TestMain(m *testing.M) { roleInfo := new(RoleInfo) _ = json.Unmarshal([]byte(apiStr), roleInfo) roleTrieTest = NewRoleTrie() roleTrieTest.Generate(*roleInfo) roleRegTest = NewRegexp() roleRegTest.GenerateReg(*roleInfo) m.Run() } func Benchmark_TrieSearch(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if roleTrieTest.Search(5, url1, http.MethodGet) != true { b.Fatal(\u0026#34;Benchmark_TrieSearch url1 has failed\u0026#34;) } if roleTrieTest.Search(5, url2, http.MethodPost) != false { b.Fatal(\u0026#34;Benchmark_TrieSearch url2 has failed\u0026#34;) } } } func Benchmark_RegSearch(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if roleRegTest.Search(5, url1, http.MethodGet) != true { b.Fatal(\u0026#34;Benchmark_RegSearch url1 has failed\u0026#34;) } if roleRegTest.Search(5, url2, http.MethodPost) != false { b.Fatal(\u0026#34;Benchmark_RegSearch url2 has failed\u0026#34;) } } }   测试结果 性能上的差别大概在210倍左右。 其中RegSearch方法的性能主要在正则匹配上损耗，TrieSearch则主要在对入参的URL进行字符串分割\n1 2 3 4 5 6 7 8 9  go test -bench . -benchmem goos: windows goarch: amd64 pkg: CodeCollection/search-path cpu: AMD Ryzen 5 3600X 6-Core Processor Benchmark_TrieSearch-12 3217045 371.9 ns/op 160 B/op 2 allocs/op Benchmark_RegSearch-12 15277 78974 ns/op 85607 B/op 534 allocs/op PASS ok CodeCollection/search-path 3.856s   完整代码 完整代码\n","date":"2022-07-25T13:42:11Z","permalink":"https://zhongyang.wang/post/1658727731/","title":"路由匹配方式比较"},{"content":"前言 Consul 是一个服务网格解决方案，提供具有服务发现、配置和分段功能的全功能控制平面。这些功能中的每一个都可以根据需要单独使用，也可以一起使用来构建完整的service mesh。\n安转Consul和Fabio Install Consul\nFabio Quickstart\n我这里采用本地运行的方式\n  运行consul\n1  ./consul.exe agent -dev   web页面地址localhost:8500\n  运行Fabio\n注意此处的端口号及协议类型\n1  ./fabio-1.6.0-windows_amd64.exe -proxy.addr \u0026#39;:10000;proto=grpc\u0026#39;   web 页面地址http://localhost:9998/\n  gRPC服务端   golang代码如下，其中要注意的点：1、 registrationInfo.ID 不能重复；2、registrationInfo.Tags 需要有前缀才能被Fabio代理，以及协议要与前面启动Fabio处要对应；3、registrationInfo.Check 需要添加，因为Fabio只对健康检测通过的服务进行监控\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  package main import ( \u0026#34;context\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; pb \u0026#34;google.golang.org/grpc/examples/helloworld/helloworld\u0026#34; \u0026#34;github.com/hashicorp/consul/api\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; ) var ( port *int client *api.Client serverId string ) // server is used to implement helloworld.GreeterServer. type server struct { pb.UnimplementedGreeterServer port int } type Resp struct { Port int `json:\u0026#34;port\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` } // SayHello implements helloworld.GreeterServer func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) { resp, _ := json.Marshal( Resp{ Port: s.port, Name: in.GetName(), }) return \u0026amp;pb.HelloReply{Message: string(resp)}, nil } func main() { defer client.Agent().ServiceDeregister(serverId) lis, err := net.Listen(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;:%d\u0026#34;, *port)) if err != nil { log.Fatalf(\u0026#34;failed to listen: %v\u0026#34;, err) } s := grpc.NewServer() pb.RegisterGreeterServer(s, \u0026amp;server{port: *port}) log.Printf(\u0026#34;server listening at %v\u0026#34;, lis.Addr()) if err := s.Serve(lis); err != nil { log.Fatalf(\u0026#34;failed to serve: %v\u0026#34;, err) } } func init() { port = flag.Int(\u0026#34;port\u0026#34;, 50051, \u0026#34;The server port\u0026#34;) flag.Parse() serverId = fmt.Sprintf(\u0026#34;gRPC_id_%d\u0026#34;, *port) Registration(*port) } func Registration(port int) { var err error client, err = api.NewClient(api.DefaultConfig()) if err != nil { panic(err) } //注册信息  registrationInfo := api.AgentServiceRegistration{ ID: serverId, Name: \u0026#34;gRPCServer\u0026#34;, Port: port, Tags: []string{\u0026#34;urlprefix-/\u0026#34;, \u0026#34;proto=grpc\u0026#34;}, Address: \u0026#34;192.168.1.103\u0026#34;, Check: \u0026amp;api.AgentServiceCheck{ CheckID: fmt.Sprintf(\u0026#34;gRPCServerCheck:%d\u0026#34;, port), TCP: fmt.Sprintf(\u0026#34;192.168.1.103:%d\u0026#34;, port), Interval: \u0026#34;2s\u0026#34;, Timeout: \u0026#34;5s\u0026#34;, }, } if err = client.Agent().ServiceRegister(\u0026amp;registrationInfo); err != nil { log.Fatalf(\u0026#34;ServiceRegister error:%s\u0026#34;, err.Error()) } }     在三个终端运行服务\n1 2 3  go run main.go -port=50001 go run main.go -port=50002 go run main.go -port=50003     运行效果 在consul中，可以看到有一个名为gRPCServer的服务，该服务下有三个示例 在Fabio中的Routing Table如图：   gRPC客户端  golang代码如下，请求的端口为启动Fabio中处的端口，(即10000) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  package main import ( \u0026#34;context\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;google.golang.org/grpc/credentials/insecure\u0026#34; pb \u0026#34;google.golang.org/grpc/examples/helloworld/helloworld\u0026#34; ) func main() { numMap := map[int]int{ 50001: 0, 50002: 0, 50003: 0, } for i := 0; i \u0026lt; 1000; i++ { respPort := Request(10000) numMap[respPort]++ } log.Println(\u0026#34;numMap: \u0026#34;, numMap) } func Request(port int) int { addr := fmt.Sprintf(\u0026#34;192.168.1.103:%d\u0026#34;, port) conn, err := grpc.Dial(addr, grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil { log.Fatalf(\u0026#34;did not connect: %v\u0026#34;, err) } //resolver.SetDefaultScheme()  defer conn.Close() c := pb.NewGreeterClient(conn) r, err := c.SayHello(context.Background(), \u0026amp;pb.HelloRequest{Name: \u0026#34;myName\u0026#34;}) if err != nil { log.Fatalf(\u0026#34;could not greet: %s\u0026#34;, err.Error()) } //log.Printf(\u0026#34;resp: %s\u0026#34;, r.GetMessage())  resp := new(Resp) _ = json.Unmarshal([]byte(r.GetMessage()), resp) return resp.Port } type Resp struct { Port int `json:\u0026#34;port\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` }    运行及结果 1 2  go run main.go 2022/06/30 01:38:56 numMap: map[50001:339 50002:326 50003:335]   这里统计了各示例被请求的次数，结果与Fabio中各实例的权重相呼应  个人总结 consul相对于之前使用过的zookeeper来说，在服务发现这部分的配置会相对简单，且包含了健康检查。对于客户端来说，不需要拉取服务端列表到本地并进行故障处理和负载均衡，请求的是Fabio代理\n","date":"2022-06-30T01:01:45Z","permalink":"https://zhongyang.wang/post/1656518400/","title":"使用consul和Fabio做RPC的服务发现"},{"content":"前言 有时需要查看pod的网络数据包，但pod一般没有tcpdump命令。这里介绍如何在宿主机上对pod进行网络抓包\nnsenter 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14  nsenter [options] [program [arguments]] options: -t, --target pid：指定被进入命名空间的目标进程的pid -m, --mount[=file]：进入mount命令空间。如果指定了file，则进入file的命令空间 -u, --uts[=file]：进入uts命令空间。如果指定了file，则进入file的命令空间 -i, --ipc[=file]：进入ipc命令空间。如果指定了file，则进入file的命令空间 -n, --net[=file]：进入net命令空间。如果指定了file，则进入file的命令空间 -p, --pid[=file]：进入pid命令空间。如果指定了file，则进入file的命令空间 -U, --user[=file]：进入user命令空间。如果指定了file，则进入file的命令空间 -G, --setgid gid：设置运行程序的gid -S, --setuid uid：设置运行程序的uid -r, --root[=directory]：设置根目录 -w, --wd[=directory]：设置工作目录   抓包步骤 比如要对名为greeter-grpc-cli pod进行抓包\n1 2 3  kubectl get pods greeter-grpc-cli-deployment-5bb97fd9cc-sgmq5 -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES greeter-grpc-cli-deployment-5bb97fd9cc-sgmq5 2/2 Running 0 21d 10.32.0.12 vm-4-2-ubuntu \u0026lt;none\u0026gt; \u0026lt;none\u0026gt;    安装 nsenter  1  apt install util-linux   查找containerID  1 2 3 4 5 6 7 8  crictl ps CONTAINER IMAGE CREATED STATE NAME ATTEMPT POD ID ccfb9e0db7f97 393cf1d5c95a6 2 weeks ago Running istio-proxy 0 2f84e757f1050 9d85e6b43e69e ********/greeter-grpc@sha256:19511605390fb29beb9c87845b13b66b013340c88318c5220073aab72ce75213 2 weeks ago Running greeter-grpc-svc 0 2f84e757f1050 74c96c2f11059 393cf1d5c95a6 2 weeks ago Running istio-proxy 0 06be1fe958aa1 760cde3cabce9 ********/greeter-grpc@sha256:19511605390fb29beb9c87845b13b66b013340c88318c5220073aab72ce75213 2 weeks ago Running greeter-grpc-svc 0 06be1fe958aa1 900286bf1bbfe 393cf1d5c95a6 2 weeks ago Running istio-proxy 0 22d9e9f643cb8 7116f44850a08 ********/greeter-grpc-client@sha256:038dcbc6c3df21dda59d925d6185fe95179aef4418229d1cdf62fbf89e599ce1 2 weeks ago Running greeter-grpc-cli 0 22d9e9f643cb8   查找PID  1 2 3  docker top 7116f44850a08 UID PID PPID C STIME TTY TIME CMD root 1712108 1712089 0 Apr10 ? 00:00:27 /opt/app/server   进入pod所在的命名空间  1  nsenter -n -t 1712108   查看是否已经进入pod的命名空间 可以看到此处只显示了两个网卡eth0的地址与上面查看pod的内网地址相同，说明已经进入了  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  ifconfig eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1376 inet 10.32.0.12 netmask 255.240.0.0 broadcast 10.47.255.255 ether b2:0e:5d:4c:d3:70 txqueuelen 0 (Ethernet) RX packets 6150082 bytes 626075350 (626.0 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 4340063 bytes 449149455 (449.1 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 2728060 bytes 401944336 (401.9 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2728060 bytes 401944336 (401.9 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0   使用tcpdump进行抓包 此处的端口为pod对外暴露的地址，而不是通过宿主机对外的端口  1  tcpdump -nnnvv -As 0 -i eth0 port 8000 -w test.pcap   下载抓包文件test.pcap到本机，使用wireshark查看 信息如下   ","date":"2022-05-01T15:21:48Z","permalink":"https://zhongyang.wang/post/1651389708/","title":"对K8S的pod进行抓包"},{"content":"前言 Mysql Binlog是二进制格式的日志文件，但是不能把binlog文件等同于OS系统某目录下的具体文件，这是狭隘的。Binlog是用来记录Mysql内部对数据库的改动（只记录对数据的修改操作），主要用于数据库的主从复制以及增量恢复。\n查看是否开启 1  showVARIABLESlike\u0026#39;%log_bin%\u0026#39;  在MySQL配置文件开启binlog日志的两种方式  第一种 1 2 3 4 5 6  # 开启binlog log_bin=ON # binlog日志的基本文件名 log_bin_basename=/etc/mysql/log_bin_data/log_bin # binlog文件的索引文件，管理所有binlog文件 log_bin_index=/etc/mysql/log_bin_data/log_bin.index    第二种 1 2 3 4  # 开启binlog 这一行在5.7版本不加没有效果 log_bin=ON log-bin=/etc/mysql/log_bin_data/log_bin   binlog 文件路径为 /etc/mysql/log_bin_data/  查看结果 1  showVARIABLESlike\u0026#39;%log_bin%\u0026#39;  查看bin log 文件地址\n1  ls /etc/mysql/log_bin_data/log_bin   解码查看binlog文件 1  mysqlbinlog log_bin.000002 --base64-output=decode-rows -v   ","date":"2020-02-28T16:08:19Z","permalink":"https://zhongyang.wang/post/1529598446/","title":"MySQL添加bin-log"},{"content":"前言 Oh My Zsh 是一个开源的、社区驱动的框架，用于管理您的 Zsh 配置。可以利用数百个强大的插件和精美的主题\n安装zsh  install  1  apt install zsh    验证安装  1  zsh --version    设置默认shell  1  chsh -s /bin/zsh    查看默认shell  1  echo $SHELL   输出\n1  /usr/bin/zsh   安装和配置oh-my-zsh 框架  安装所需工具  1  apt install wget git    下载并执行安装脚本  1  wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zsh    copy配置文件  1 2  cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc source ~/.zshrc    完成的结果  1  ➜ ~   zsh官网\n","date":"2019-12-06T11:53:30Z","permalink":"https://zhongyang.wang/post/1575561600/","title":"Ubuntu 安装ZSH"}]